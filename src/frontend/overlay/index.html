<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Twitch Redeem Overlay</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: rgba(0, 0, 0, 0);
      -webkit-app-region: drag;
    }

    #overlay-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .overlay-item {
      position: absolute;
      background-repeat: no-repeat;
      background-size: contain;
      background-position: center;
    }

    .overlay-video, .overlay-gif {
      overflow: hidden;
    }
    
    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .chroma-key-filter {
      -webkit-backdrop-filter: contrast(1.5);
      backdrop-filter: contrast(1.5);
    }
    
    /* Red border styles */
    .border-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: 3px solid rgba(255, 0, 0, 0.6);
      box-sizing: border-box;
      pointer-events: none;
      z-index: 9999;
    }
    
    /* Toggle button for border visibility */
    #toggle-border {
      position: fixed;
      top: 5px;
      right: 5px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      border-radius: 3px;
      padding: 2px 5px;
      font-size: 10px;
      cursor: pointer;
      z-index: 10000;
      opacity: 0.3;
      transition: opacity 0.3s;
    }
    
    #toggle-border:hover {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="overlay-container"></div>
  <div class="border-container" id="border-container"></div>
  <button id="toggle-border">Hide Border</button>

  <script>
    // Border visibility toggle
    const borderElement = document.getElementById('border-container');
    const toggleButton = document.getElementById('toggle-border');
    let borderVisible = true;
    
    toggleButton.addEventListener('click', () => {
      borderVisible = !borderVisible;
      borderElement.style.display = borderVisible ? 'block' : 'none';
      toggleButton.textContent = borderVisible ? 'Hide Border' : 'Show Border';
    });
    
    // Auto-hide toggle button after 5 seconds
    setTimeout(() => {
      toggleButton.style.opacity = '0';
    }, 5000);
    
    // Show toggle button when mouse moves
    document.addEventListener('mousemove', () => {
      toggleButton.style.opacity = '0.3';
      clearTimeout(window.hideButtonTimer);
      window.hideButtonTimer = setTimeout(() => {
        toggleButton.style.opacity = '0';
      }, 3000);
    });
    
    // Cache to store media dimensions
    const mediaDimensions = new Map();
    
    // Listen for overlay display commands from main process
    window.electron.receive('display-overlay', (data) => {
      displayOverlayItem(data);
    });
    
    // Listen for cache clearing commands
    window.electron.receive('clear-cache', () => {
      clearLocalCache();
    });
    
    // Function to clear local cache of dimensions
    function clearLocalCache() {
      mediaDimensions.clear();
      console.log('Local media cache cleared');
    }
    
    // Function to apply chroma key via CSS filters
    function applyChromaKey(element, chromaKey) {
      if (!chromaKey) return;
      
      try {
        // Convert hex to rgb if needed
        let color = chromaKey;
        if (color.startsWith('#')) {
          const r = parseInt(color.slice(1, 3), 16);
          const g = parseInt(color.slice(3, 5), 16);
          const b = parseInt(color.slice(5, 7), 16);
          color = `rgb(${r}, ${g}, ${b})`;
        }
        
        // Create a WebGL canvas for chroma keying
        const canvas = document.createElement('canvas');
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.zIndex = '2';
        
        // Add a class to help with styling
        element.classList.add('chroma-key-element');
        
        // Use CSS mix-blend-mode for simple chroma keying
        if (element.tagName === 'VIDEO') {
          // For videos we need to use a different approach
          element.style.mixBlendMode = 'multiply';
        } else {
          // For images/gifs we can use background-blend-mode
          element.style.backgroundColor = color;
          element.style.backgroundBlendMode = 'screen';
        }
        
        console.log(`Applied chroma key: ${color}`);
      } catch (err) {
        console.error('Error applying chroma key:', err);
      }
    }
    
    // Function to get the natural dimensions of media
    function getMediaDimensions(src, type) {
      return new Promise((resolve) => {
        // Check cache first
        if (mediaDimensions.has(src)) {
          resolve(mediaDimensions.get(src));
          return;
        }
        
        if (type === 'video') {
          const video = document.createElement('video');
          video.onloadedmetadata = () => {
            const dimensions = {
              width: video.videoWidth,
              height: video.videoHeight
            };
            mediaDimensions.set(src, dimensions);
            resolve(dimensions);
          };
          video.onerror = () => resolve(null);
          video.src = src;
        } else {
          const img = new Image();
          img.onload = () => {
            const dimensions = {
              width: img.naturalWidth,
              height: img.naturalHeight
            };
            mediaDimensions.set(src, dimensions);
            resolve(dimensions);
          };
          img.onerror = () => resolve(null);
          img.src = src;
        }
      });
    }

    async function displayOverlayItem(data) {
      const container = document.getElementById('overlay-container');
      let item;
      
      // If no dimensions are specified, try to get natural media dimensions
      if (!data.width || !data.height) {
        const naturalSize = await getMediaDimensions(data.path, data.type);
        if (naturalSize) {
          data.width = naturalSize.width;
          data.height = naturalSize.height;
          
          // If media is too large for the screen, scale it down
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;
          
          if (data.width > windowWidth || data.height > windowHeight) {
            const widthRatio = windowWidth / data.width;
            const heightRatio = windowHeight / data.height;
            const ratio = Math.min(widthRatio, heightRatio);
            
            data.width = Math.floor(data.width * ratio);
            data.height = Math.floor(data.height * ratio);
          }
        }
      }
      
      if (data.type === 'video') {
        // Create a video element for MP4 files
        const videoContainer = document.createElement('div');
        videoContainer.className = 'overlay-item overlay-video';
        videoContainer.style.left = `${data.x}px`;
        videoContainer.style.top = `${data.y}px`;
        videoContainer.style.width = data.width ? `${data.width}px` : 'auto';
        videoContainer.style.height = data.height ? `${data.height}px` : 'auto';
        
        const video = document.createElement('video');
        video.autoplay = true;
        video.loop = false;
        video.muted = true;  // Muted by default
        video.src = data.path;
        
        // Apply chroma key if specified
        if (data.chromaKey) {
          applyChromaKey(video, data.chromaKey);
        }
        
        videoContainer.appendChild(video);
        container.appendChild(videoContainer);
        
        // Auto-remove after duration or when video ends
        const removeVideo = () => {
          if (videoContainer && videoContainer.parentNode) {
            videoContainer.parentNode.removeChild(videoContainer);
          }
        };
        
        video.onended = removeVideo;
        setTimeout(removeVideo, data.duration);
        
        item = videoContainer;
      } else {
        // Create div for GIFs and images
        item = document.createElement('div');
        item.className = `overlay-item overlay-${data.type}`;
        
        // Position the item
        item.style.left = `${data.x}px`;
        item.style.top = `${data.y}px`;
        item.style.width = data.width ? `${data.width}px` : 'auto';
        item.style.height = data.height ? `${data.height}px` : 'auto';
        
        // Set the background image
        item.style.backgroundImage = `url('${data.path}')`;
        
        // Apply chroma key if specified
        if (data.chromaKey) {
          applyChromaKey(item, data.chromaKey);
        }
        
        // Add to container
        container.appendChild(item);
        
        // Remove after duration
        setTimeout(() => {
          if (item && item.parentNode) {
            item.parentNode.removeChild(item);
          }
        }, data.duration);
      }
    }
    
    // Listen for border toggle commands from main process
    window.electron.receive('toggle-border', (visible) => {
      borderVisible = visible;
      borderElement.style.display = borderVisible ? 'block' : 'none';
      toggleButton.textContent = borderVisible ? 'Hide Border' : 'Show Border';
    });
  </script>
</body>
</html>